<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>Wegbeschreibung </title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=reset_focus"
    />
    <style>
      html,
      body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        background: #f0f0f0;
        font-family: Arial, Helvetica, sans-serif;
      }

      #viewer {
        width: 100vw;
        height: 100vh;
        display: block;
        touch-action: none;
      }

      #resetView {
        position: fixed;
        right: 24px;
        bottom: 24px;
        width: 52px;
        height: 52px;
        border: none;
        border-radius: 50%;
        background-color: #ffffff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      #resetView:hover,
      #resetView:focus {
        outline: none;
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }

      #resetView .material-symbols-outlined {
        font-family: "Material Symbols Outlined";
        font-variation-settings:
          "FILL" 0,
          "wght" 400,
          "GRAD" 0,
          "opsz" 24;
        font-size: 26px;
        color: #000000;
      }


    </style>
  </head>
  <body>
    <canvas id="viewer"></canvas>
    <button id="resetView" type="button" aria-label="Ansicht zurücksetzen">
      <span class="material-symbols-outlined" aria-hidden="true">reset_focus</span>
    </button>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      const canvas = document.getElementById("viewer");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        preserveDrawingBuffer: true,
      });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 7);
      scene.add(directionalLight);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = true;
      controls.enableRotate = false;
      controls.enableZoom = true;
      controls.screenSpacePanning = false;
      controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
      controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
      controls.touches.ONE = THREE.TOUCH.PAN;
      controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = 0;
      controls.update();

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      let model = null;
      let lastTapTime = 0;
      const tapThresholdMs = 300;
      const resetButton = document.getElementById("resetView");
      const zoomState = {
        active: false,
        startTarget: new THREE.Vector3(),
        endTarget: new THREE.Vector3(),
        startPosition: new THREE.Vector3(),
        endPosition: new THREE.Vector3(),
        startTime: 0,
        duration: 350,
      };
      let controlsStateChanged = false;

      function approxEquals(vecA, vecB, epsilon = 1e-4) {
        return (
          Math.abs(vecA.x - vecB.x) <= epsilon &&
          Math.abs(vecA.y - vecB.y) <= epsilon &&
          Math.abs(vecA.z - vecB.z) <= epsilon
        );
      }

      function startZoomAnimation(targetVec, positionVec, duration = 350) {
        zoomState.active = false;
        zoomState.startTarget.copy(controls.target);
        zoomState.startPosition.copy(camera.position);
        zoomState.endTarget.copy(targetVec);
        zoomState.endPosition.copy(positionVec);
        zoomState.duration = duration;
        zoomState.startTime = performance.now();
        zoomState.active = true;
        controlsStateChanged = true;
      }

      function zoomToPoint(point, factor = 0.5) {
        const direction = new THREE.Vector3().copy(camera.position).sub(controls.target);
        const currentDistance = direction.length();
        const desiredDistance = Math.max(currentDistance * factor, 0.5);
        direction.setLength(desiredDistance);

        const targetPoint = new THREE.Vector3().copy(point);
        const endPosition = new THREE.Vector3().copy(point).add(direction);
        startZoomAnimation(targetPoint, endPosition);
      }

      function handleZoomEvent(clientX, clientY) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(pointer, camera);

        let targetPoint = new THREE.Vector3();
        const intersects = model ? raycaster.intersectObject(model, true) : [];

        if (intersects.length > 0) {
          targetPoint.copy(intersects[0].point);
        } else {
          const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
          if (!raycaster.ray.intersectPlane(groundPlane, targetPoint)) {
            return;
          }
        }

        zoomToPoint(targetPoint);
      }

      const loader = new GLTFLoader();
      let fittedDistance = null;
      
      // Funktion zum nacheinander Einblenden der Meshes
      function animateMeshesAppearance(meshes, delayPerMesh = 20) {
        meshes.forEach((mesh, index) => {
          // Zunächst alle Meshes unsichtbar machen
          mesh.visible = false;
          
          // Speichere die ursprüngliche Transparenz-Einstellung
          let originalTransparent = false;
          let originalOpacity = 1;
          
          if (mesh.material && Array.isArray(mesh.material)) {
            const originalStates = mesh.material.map(mat => ({
              transparent: mat.transparent || false,
              opacity: mat.opacity !== undefined ? mat.opacity : 1
            }));
            
            mesh.material.forEach((mat, matIndex) => {
              mat.transparent = true;
              mat.opacity = 0;
            });
            
            // Mesh nach einer Verzögerung einblenden
            setTimeout(() => {
              mesh.visible = true;
              // Fade-in-Animation für alle Materialien
              const startTime = Date.now();
              const duration = 300; // 300ms Fade-in
              const fadeIn = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                mesh.material.forEach((mat, matIndex) => {
                  mat.opacity = originalStates[matIndex].opacity * progress;
                });
                
                if (progress < 1) {
                  requestAnimationFrame(fadeIn);
                } else {
                  // Stelle ursprüngliche Transparenz-Einstellung wieder her
                  mesh.material.forEach((mat, matIndex) => {
                    mat.transparent = originalStates[matIndex].transparent;
                    mat.opacity = originalStates[matIndex].opacity;
                  });
                }
              };
              requestAnimationFrame(fadeIn);
            }, index * delayPerMesh);
          } else if (mesh.material) {
            originalTransparent = mesh.material.transparent || false;
            originalOpacity = mesh.material.opacity !== undefined ? mesh.material.opacity : 1;
            
            mesh.material.transparent = true;
            mesh.material.opacity = 0;
            
            // Mesh nach einer Verzögerung einblenden
            setTimeout(() => {
              mesh.visible = true;
              const startTime = Date.now();
              const duration = 300;
              const fadeIn = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                mesh.material.opacity = originalOpacity * progress;
                if (progress < 1) {
                  requestAnimationFrame(fadeIn);
                } else {
                  // Stelle ursprüngliche Transparenz-Einstellung wieder her
                  mesh.material.transparent = originalTransparent;
                  mesh.material.opacity = originalOpacity;
                }
              };
              requestAnimationFrame(fadeIn);
            }, index * delayPerMesh);
          } else {
            // Fallback: Einfach sichtbar machen ohne Fade-in
            setTimeout(() => {
              mesh.visible = true;
            }, index * delayPerMesh);
          }
        });
      }
      
      // Custom loader für Git LFS Dateien
      async function loadGLBWithLFS(url, onLoad, onError) {
        try {
          
          // Versuche die Datei zu laden
          const response = await fetch(url);
          
          // Prüfe ob die Antwort erfolgreich war
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const contentLength = response.headers.get('content-length');
          const total = contentLength ? parseInt(contentLength, 10) : 0;
          const reader = response.body.getReader();
          
          // Lade die Datei mit Progress-Tracking
          const chunks = [];
          let received = 0;
          let text = null;
          let isPointerDetected = false;
          
          // Lese Stream-Chunk für Chunk
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            chunks.push(value);
            received += value.length;
            
            // Prüfe auf Pointer-Datei, wenn wir genug Bytes haben
            if (!isPointerDetected && received >= 500) {
              const firstBlob = new Blob(chunks);
              text = await firstBlob.text();
              isPointerDetected = true;
            }
          }
          
          const blob = new Blob(chunks);
          
          // Wenn wir noch keinen Text haben, hole ihn jetzt
          if (!text) {
            text = await blob.text();
          }
          
          // Prüfe ob es eine Git LFS Pointer-Datei ist
          if (text.startsWith('version https://git-lfs.github.com/spec/v1')) {
            // Es ist eine LFS Pointer-Datei, lade von GitHub
            const filePath = 'Wegbeschreibungen/Agatharied/Deutsch/Erdgeschoss.glb';
            
            const urls = [
              `https://media.githubusercontent.com/media/Herold-Simon/seraphin-solutions-website/main/${encodeURIComponent(filePath)}`,
              `https://raw.githubusercontent.com/Herold-Simon/seraphin-solutions-website/main/${encodeURIComponent(filePath)}`,
              `https://github.com/Herold-Simon/seraphin-solutions-website/raw/main/${encodeURIComponent(filePath)}`
            ];
            
            let loaded = false;
            for (const githubUrl of urls) {
              try {
                const githubResponse = await fetch(githubUrl, {
                  headers: { 'Accept': 'application/octet-stream' }
                });
                
                if (githubResponse.ok) {
                  const githubContentLength = githubResponse.headers.get('content-length');
                  const githubTotal = githubContentLength ? parseInt(githubContentLength, 10) : 0;
                  const githubReader = githubResponse.body.getReader();
                  const githubChunks = [];
                  let githubReceived = 0;
                  
                  // Lade von GitHub mit Progress
                  while (true) {
                    const { done, value } = await githubReader.read();
                    if (done) break;
                    
                  githubChunks.push(value);
                  githubReceived += value.length;
                  }
                  
                  const githubBlob = new Blob(githubChunks);
                  
                  // Prüfe ob es nicht wieder eine Pointer-Datei ist
                  const firstChunk = await githubBlob.slice(0, 200).text();
                  if (firstChunk.startsWith('version https://git-lfs.github.com/spec/v1')) {
                    console.warn(`URL ${githubUrl} lieferte noch eine Pointer-Datei, versuche nächste URL...`);
                    continue;
                  }
                  
                  // Lade über GLTFLoader
                  const objectUrl = URL.createObjectURL(githubBlob);
                  loader.load(objectUrl, onLoad, undefined, (error) => {
                    URL.revokeObjectURL(objectUrl);
                    onError(error);
                  });
                  loaded = true;
                  break;
                }
              } catch (e) {
                console.warn(`URL ${githubUrl} fehlgeschlagen:`, e);
                continue;
              }
            }
            
            if (!loaded) {
              throw new Error(`Konnte LFS-Datei nicht laden. GitHub Pages unterstützt Git LFS nicht direkt.`);
            }
          } else {
            // Es ist keine LFS Pointer-Datei, lade direkt
            const objectUrl = URL.createObjectURL(blob);
            loader.load(objectUrl, onLoad, undefined, (error) => {
              URL.revokeObjectURL(objectUrl);
              onError(error);
            });
          }
        } catch (error) {
          console.error('Fehler beim Laden der GLB-Datei:', error);
          onError(error);
        }
      }
      
      loadGLBWithLFS(
        "./Erdgeschoss.glb",
        (gltf) => {
          model = gltf.scene;
          scene.add(model);
          
          // Sammle alle Meshes
          const meshes = [];
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              meshes.push(child);
            }
          });
          
          // Zeige alle Meshes nacheinander an
          animateMeshesAppearance(meshes, 20);

          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          model.position.sub(center);

          const fov = THREE.MathUtils.degToRad(camera.fov);
          const aspect = camera.aspect || (window.innerWidth / window.innerHeight);

          const halfSizeX = Math.max(size.x, 0.001) * 0.5;
          const halfSizeZ = Math.max(size.z, 0.001) * 0.5;

          const distanceForHeight = halfSizeZ / Math.tan(fov / 2);
          const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspect);
          const distanceForWidth = halfSizeX / Math.tan(horizontalFov / 2);

          const distance = Math.max(distanceForHeight, distanceForWidth) * 1.2;
          fittedDistance = distance;

          const initialTarget = new THREE.Vector3(0, 0, 0);
          const initialPosition = new THREE.Vector3(
            initialTarget.x,
            initialTarget.y + distance,
            initialTarget.z
          );

          camera.position.copy(initialPosition);
          camera.lookAt(initialTarget);

          controls.target.copy(initialTarget);
          controls.minDistance = 0;
          controls.maxDistance = Infinity;
          controls.update();
          controls.saveState();

          // Suche nach Objekten, die mit "zooming" beginnen (z.B. "zooming", "zooming1", "zooming2", etc.)
          let focusMesh = null;
          model.traverse((child) => {
            if (child.name && child.name.match(/^zooming\d*$/i)) {
              focusMesh = child;
            }
          });
          
          if (focusMesh) {
            // Position des zooming-Objekts in Weltkoordinaten nach der Zentrierung berechnen
            model.updateMatrixWorld(true);
            
            // Bounding Box direkt in Weltkoordinaten berechnen
            const worldBox = new THREE.Box3();
            const tempVector = new THREE.Vector3();
            let hasVertices = false;
            
            focusMesh.traverse((child) => {
              if (child.isMesh && child.geometry) {
                child.updateMatrixWorld(true);
                const geometry = child.geometry;
                const positionAttribute = geometry.attributes.position;
                
                if (positionAttribute) {
                  for (let i = 0; i < positionAttribute.count; i++) {
                    tempVector.fromBufferAttribute(positionAttribute, i);
                    tempVector.applyMatrix4(child.matrixWorld);
                    if (!hasVertices) {
                      worldBox.setFromPoints([tempVector]);
                      hasVertices = true;
                    } else {
                      worldBox.expandByPoint(tempVector);
                    }
                  }
                }
              }
            });
            
            // Fallback: Falls keine Vertices gefunden wurden, verwende setFromObject
            if (!hasVertices) {
              worldBox.setFromObject(focusMesh);
            }
            
            const worldCenter = new THREE.Vector3();
            worldBox.getCenter(worldCenter);
            const focusSize = worldBox.getSize(new THREE.Vector3());

            const halfFocusX = Math.max(focusSize.x, 0.001) * 0.5;
            const halfFocusZ = Math.max(focusSize.z, 0.001) * 0.5;

            const focusDistanceForHeight = halfFocusZ / Math.tan(fov / 2);
            const focusDistanceForWidth = halfFocusX / Math.tan(horizontalFov / 2);
            const focusDistance =
              Math.max(focusDistanceForHeight, focusDistanceForWidth) * 1.1;

            // Kamera direkt über dem zooming-Objekt positionieren (von oben schauen)
            // Damit ist das Objekt genau zentriert und nicht vom Rest des Modells beeinflusst
            const focusPosition = new THREE.Vector3(
              worldCenter.x,
              worldCenter.y + focusDistance,
              worldCenter.z
            );

            focusMesh.traverse((child) => {
              child.visible = false;
            });

            if (controls.target0) {
              controls.target0.copy(worldCenter);
            }
            if (controls.position0) {
              controls.position0.copy(focusPosition);
            }
            if (controls.zoom0 !== undefined) {
              controls.zoom0 = camera.zoom;
            }

            const focusDelayMs = 600;
            const focusDurationMs = 1600;
            setTimeout(() => {
              startZoomAnimation(worldCenter, focusPosition, focusDurationMs);
            }, focusDelayMs);
          }
        },
        (error) => {
          console.error("Fehler beim Laden der GLB-Datei:", error);
        }
      );

      function animate() {
        requestAnimationFrame(animate);
        if (zoomState.active) {
          const elapsed = performance.now() - zoomState.startTime;
          let t = elapsed / zoomState.duration;
          if (t >= 1) {
            zoomState.active = false;
            controls.target.copy(zoomState.endTarget);
            camera.position.copy(zoomState.endPosition);
            // Stelle sicher, dass die Kamera genau auf das Target schaut
            camera.lookAt(controls.target);
            controls.update();
          } else {
            const eased = THREE.MathUtils.smoothstep(t, 0, 1);
            controls.target
              .copy(zoomState.startTarget)
              .lerp(zoomState.endTarget, eased);
            camera.position
              .copy(zoomState.startPosition)
              .lerp(zoomState.endPosition, eased);
            camera.lookAt(controls.target);
          }
          controls.update();
          updateResetButtonVisibility();
        } else if (controlsStateChanged) {
          updateResetButtonVisibility();
          controlsStateChanged = false;
        }
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderer.domElement.addEventListener("dblclick", (event) => {
        event.preventDefault();
        handleZoomEvent(event.clientX, event.clientY);
      });

      renderer.domElement.addEventListener(
        "touchend",
        (event) => {
          if (event.touches.length > 0) {
            return;
          }

          const currentTime = performance.now();
          if (currentTime - lastTapTime < tapThresholdMs) {
            const touch = event.changedTouches[0];
            handleZoomEvent(touch.clientX, touch.clientY);
            lastTapTime = 0;
          } else {
            lastTapTime = currentTime;
          }
        },
        { passive: false }
      );

      resetButton.addEventListener("click", () => {
        const savedTarget = controls.target0 ? controls.target0.clone() : new THREE.Vector3();
        const savedPosition = controls.position0
          ? controls.position0.clone()
          : new THREE.Vector3().copy(camera.position);
        startZoomAnimation(savedTarget, savedPosition);
      });

      function updateResetButtonVisibility() {
        const targetChanged = !approxEquals(controls.target, controls.target0);
        const positionChanged = !approxEquals(camera.position, controls.position0);
        const shouldBeVisible = targetChanged || positionChanged || zoomState.active;
        resetButton.style.display = shouldBeVisible ? "flex" : "none";
      }

      controls.addEventListener("change", () => {
        controlsStateChanged = true;
      });

      updateResetButtonVisibility();
    </script>
  </body>
</html>

