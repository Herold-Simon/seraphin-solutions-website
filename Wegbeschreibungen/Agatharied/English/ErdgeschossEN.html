<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Directions</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
    />
    <style>
      html,
      body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        background: #f0f0f0;
        font-family: Arial, Helvetica, sans-serif;
      }

      #viewer {
        width: 100vw;
        height: 100vh;
        display: block;
        touch-action: none;
      }

      #resetView {
        position: fixed;
        right: 24px;
        bottom: 24px;
        width: 52px;
        height: 52px;
        border: none;
        border-radius: 50%;
        background-color: #ffffff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      #resetView:hover,
      #resetView:focus {
        outline: none;
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }

      #resetView .material-symbols-outlined {
        font-family: "Material Symbols Outlined";
        font-variation-settings:
          "FILL" 0,
          "wght" 400,
          "GRAD" 0,
          "opsz" 24;
        font-size: 26px;
        color: #000000;
      }

      #progressContainer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(240, 240, 240, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.3s ease;
      }

      #progressContainer.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #progressBarWrapper {
        width: 80%;
        max-width: 400px;
        background-color: #e0e0e0;
        border-radius: 20px;
        height: 24px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #progressBar {
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #45a049);
        width: 0%;
        transition: width 0.2s ease;
        border-radius: 20px;
      }

      #progressText {
        margin-top: 20px;
        font-size: 16px;
        color: #333;
        font-weight: 500;
      }

      #progressDetails {
        margin-top: 12px;
        font-size: 13px;
        color: #666;
        font-weight: 400;
      }

      #progressSpeed {
        margin-top: 8px;
        font-size: 12px;
        color: #888;
      }

      #backButton {
        position: fixed;
        left: 24px;
        top: 24px;
        width: 52px;
        height: 52px;
        border: none;
        border-radius: 50%;
        background-color: #ffffff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        z-index: 100;
        text-decoration: none;
        color: inherit;
      }

      #backButton:hover,
      #backButton:focus {
        outline: none;
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }

      #backButton .material-symbols-outlined {
        font-family: "Material Symbols Outlined";
        font-variation-settings:
          "FILL" 1,
          "wght" 400,
          "GRAD" 0,
          "opsz" 24;
        font-size: 26px;
        color: #000000;
      }

      #languageDropdown {
        position: fixed;
        left: 24px;
        bottom: 24px;
        z-index: 100;
      }

      #languageButton {
        width: 52px;
        height: 52px;
        border: none;
        border-radius: 50%;
        background-color: #ffffff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      #languageButton:hover,
      #languageButton:focus {
        outline: none;
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }

      #languageButton .flag-icon {
        font-size: 32px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        overflow: hidden;
        background: transparent;
      }

      #languageMenu {
        position: absolute;
        bottom: 60px;
        left: 0;
        background-color: #ffffff;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transform: translateY(10px);
        transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
        min-width: 140px;
      }

      #languageDropdown.open #languageMenu {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }

      #languageMenu a {
        display: flex;
        align-items: center;
        padding: 12px 20px;
        text-decoration: none;
        color: #000000;
        font-size: 15px;
        font-weight: 500;
        transition: background-color 0.2s ease;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        cursor: pointer;
        font-family: Arial, Helvetica, sans-serif;
      }

      #languageMenu a .flag {
        font-size: 20px;
        margin-right: 10px;
        line-height: 1;
      }

      #languageMenu a:hover,
      #languageMenu a:focus {
        background-color: #f5f5f5;
        outline: none;
      }

      #languageMenu a:first-child {
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
      }

      #languageMenu a:last-child {
        border-bottom-left-radius: 12px;
        border-bottom-right-radius: 12px;
      }

    </style>
  </head>
  <body>
    <div id="progressContainer">
      <div id="progressBarWrapper">
        <div id="progressBar"></div>
      </div>
      <div id="progressText">Loading floor plan...</div>
      <div id="progressDetails"></div>
      <div id="progressSpeed"></div>
    </div>
    <canvas id="viewer"></canvas>
    <a href="https://seraphin-solutions.de/Wegbeschreibungen/Agatharied/Deutsch/verzeichnis.html" id="backButton" aria-label="Back to directory">
      <span class="material-symbols-outlined" aria-hidden="true">arrow_back</span>
    </a>
    <button id="resetView" type="button" aria-label="Reset view">
      <span class="material-symbols-outlined" aria-hidden="true">reset_focus</span>
    </button>
    <div id="languageDropdown">
      <button id="languageButton" type="button" aria-label="Select language" aria-expanded="false">
        <span class="flag-icon" aria-hidden="true">üá¨üáß</span>
      </button>
      <div id="languageMenu" role="menu">
        <a href="https://seraphin-solutions.de/Wegbeschreibungen/Agatharied/Deutsch/Erdgeschoss.html" role="menuitem"><span class="flag">üá©üá™</span> Deutsch</a>
      </div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      const canvas = document.getElementById("viewer");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        preserveDrawingBuffer: true,
      });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1; // Leicht erh√∂ht f√ºr besseren Kontrast
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Weiche, hochwertige Schatten
      renderer.shadowMap.autoUpdate = true;

      // Professionelles Lighting-Setup f√ºr Architektur-Visualisierung
      
      // Hemispheric Light - simuliert nat√ºrliches Himmels- und Bodenlicht
      const hemiLight = new THREE.HemisphereLight(
        0xd1e0ff, // Himmelsfarbe (warmes Blau-Wei√ü)
        0x3d3d3d, // Bodenfarbe (dunkles Grau)
        0.6       // Intensit√§t
      );
      hemiLight.position.set(0, 50, 0);
      scene.add(hemiLight);

      // Haupt-Directional Light (Key Light) - Sonnenlicht
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(10, 15, 8);
      mainLight.castShadow = true;
      
      // Schatten-Konfiguration f√ºr qualitativ hochwertige Schatten
      mainLight.shadow.mapSize.width = 4096;
      mainLight.shadow.mapSize.height = 4096;
      mainLight.shadow.camera.near = 0.5;
      mainLight.shadow.camera.far = 100;
      mainLight.shadow.camera.left = -20;
      mainLight.shadow.camera.right = 20;
      mainLight.shadow.camera.top = 20;
      mainLight.shadow.camera.bottom = -20;
      mainLight.shadow.bias = -0.0001;
      mainLight.shadow.normalBias = 0.02;
      mainLight.shadow.radius = 4; // Weiche Schatten
      
      scene.add(mainLight);

      // Fill Light - weiche Aufhellung von der gegen√ºberliegenden Seite
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
      fillLight.position.set(-8, 8, -6);
      scene.add(fillLight);

      // Rim Light - f√ºr bessere Kontur und Tiefe
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
      rimLight.position.set(-5, 5, -10);
      scene.add(rimLight);

      // Zus√§tzliches Ambient Light f√ºr sehr dunkle Bereiche (subtile Erg√§nzung)
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = true;
      controls.enableRotate = false;
      controls.enableZoom = true;
      controls.screenSpacePanning = false;
      controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
      controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
      controls.touches.ONE = THREE.TOUCH.PAN;
      controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = 0;
      controls.update();

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      let model = null;
      let lastTapTime = 0;
      const tapThresholdMs = 300;
      const resetButton = document.getElementById("resetView");
      const zoomState = {
        active: false,
        startTarget: new THREE.Vector3(),
        endTarget: new THREE.Vector3(),
        startPosition: new THREE.Vector3(),
        endPosition: new THREE.Vector3(),
        startTime: 0,
        duration: 350,
      };
      let controlsStateChanged = false;

      function approxEquals(vecA, vecB, epsilon = 1e-4) {
        return (
          Math.abs(vecA.x - vecB.x) <= epsilon &&
          Math.abs(vecA.y - vecB.y) <= epsilon &&
          Math.abs(vecA.z - vecB.z) <= epsilon
        );
      }

      function startZoomAnimation(targetVec, positionVec, duration = 350) {
        zoomState.active = false;
        zoomState.startTarget.copy(controls.target);
        zoomState.startPosition.copy(camera.position);
        zoomState.endTarget.copy(targetVec);
        zoomState.endPosition.copy(positionVec);
        zoomState.duration = duration;
        zoomState.startTime = performance.now();
        zoomState.active = true;
        controlsStateChanged = true;
      }

      function zoomToPoint(point, factor = 0.5) {
        const direction = new THREE.Vector3().copy(camera.position).sub(controls.target);
        const currentDistance = direction.length();
        const desiredDistance = Math.max(currentDistance * factor, 0.5);
        direction.setLength(desiredDistance);

        const targetPoint = new THREE.Vector3().copy(point);
        const endPosition = new THREE.Vector3().copy(point).add(direction);
        startZoomAnimation(targetPoint, endPosition);
      }

      function handleZoomEvent(clientX, clientY) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(pointer, camera);

        let targetPoint = new THREE.Vector3();
        const intersects = model ? raycaster.intersectObject(model, true) : [];

        if (intersects.length > 0) {
          targetPoint.copy(intersects[0].point);
        } else {
          const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
          if (!raycaster.ray.intersectPlane(groundPlane, targetPoint)) {
            return;
          }
        }

        zoomToPoint(targetPoint);
      }

      const loader = new GLTFLoader();
      let fittedDistance = null;
      const progressContainer = document.getElementById("progressContainer");
      const progressBar = document.getElementById("progressBar");
      const progressText = document.getElementById("progressText");
      const progressDetails = document.getElementById("progressDetails");
      const progressSpeed = document.getElementById("progressSpeed");
      let isLoadingComplete = false;
      
      // Progress-Tracking Helper
      function updateProgress(phase, percent, details = "", speed = "") {
        const totalPercent = Math.min(Math.max(percent, 0), 100);
        progressBar.style.width = totalPercent + "%";
        
        const phaseNames = {
          'check': 'Checking file...',
          'download': 'Loading file...',
          'parse': 'Analyzing floor plan...',
          'init': 'Initializing scene...',
          'complete': 'Complete!'
        };
        
        progressText.textContent = phaseNames[phase] || 'Loading floor plan...';
        if (totalPercent < 100) {
          progressText.textContent += ` ${Math.round(totalPercent)}%`;
        }
        
        if (details) {
          progressDetails.textContent = details;
        }
        
        if (speed) {
          progressSpeed.textContent = speed;
        }
      }
      
      function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }
      
      function formatSpeed(bytesPerSecond) {
        return formatBytes(bytesPerSecond) + '/s';
      }

      // Load local GLB directly (no Git LFS handling)
      updateProgress('download', 0, 'Loading GLB file...');
      loader.load(
        "./ErdgeschossEN.glb",
        (gltf) => {
          // Loading abgeschlossen
          isLoadingComplete = true;
          updateProgress('complete', 100, 'Complete!', '');
          
          // Kurze Verz√∂gerung, damit der Nutzer "100%" sieht
          setTimeout(() => {
            progressContainer.classList.add("hidden");
            setTimeout(() => {
              progressContainer.style.display = "none";
            }, 300);
          }, 200);
          
          model = gltf.scene;
          scene.add(model);
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          model.position.sub(center);

          const fov = THREE.MathUtils.degToRad(camera.fov);
          const aspect = camera.aspect || (window.innerWidth / window.innerHeight);

          const halfSizeX = Math.max(size.x, 0.001) * 0.5;
          const halfSizeZ = Math.max(size.z, 0.001) * 0.5;

          const distanceForHeight = halfSizeZ / Math.tan(fov / 2);
          const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspect);
          const distanceForWidth = halfSizeX / Math.tan(horizontalFov / 2);

          const distance = Math.max(distanceForHeight, distanceForWidth) * 1.2;
          fittedDistance = distance;

          const initialTarget = new THREE.Vector3(0, 0, 0);
          const initialPosition = new THREE.Vector3(
            initialTarget.x,
            initialTarget.y + distance,
            initialTarget.z
          );

          camera.position.copy(initialPosition);
          camera.lookAt(initialTarget);

          controls.target.copy(initialTarget);
          controls.minDistance = 0;
          controls.maxDistance = Infinity;
          controls.update();
          controls.saveState();

          // Suche nach Objekten, die mit "zooming" beginnen (z.B. "zooming", "zooming1", "zooming2", etc.)
          let focusMesh = null;
          model.traverse((child) => {
            if (child.name && child.name.match(/^zooming\d*$/i)) {
              focusMesh = child;
            }
          });
          
          if (focusMesh) {
            // Position des zooming-Objekts in Weltkoordinaten nach der Zentrierung berechnen
            model.updateMatrixWorld(true);
            
            // Bounding Box direkt in Weltkoordinaten berechnen
            const worldBox = new THREE.Box3();
            const tempVector = new THREE.Vector3();
            let hasVertices = false;
            
            focusMesh.traverse((child) => {
              if (child.isMesh && child.geometry) {
                child.updateMatrixWorld(true);
                const geometry = child.geometry;
                const positionAttribute = geometry.attributes.position;
                
                if (positionAttribute) {
                  for (let i = 0; i < positionAttribute.count; i++) {
                    tempVector.fromBufferAttribute(positionAttribute, i);
                    tempVector.applyMatrix4(child.matrixWorld);
                    if (!hasVertices) {
                      worldBox.setFromPoints([tempVector]);
                      hasVertices = true;
                    } else {
                      worldBox.expandByPoint(tempVector);
                    }
                  }
                }
              }
            });
            
            // Fallback: Falls keine Vertices gefunden wurden, verwende setFromObject
            if (!hasVertices) {
              worldBox.setFromObject(focusMesh);
            }
            
            const worldCenter = new THREE.Vector3();
            worldBox.getCenter(worldCenter);
            const focusSize = worldBox.getSize(new THREE.Vector3());

            const halfFocusX = Math.max(focusSize.x, 0.001) * 0.5;
            const halfFocusZ = Math.max(focusSize.z, 0.001) * 0.5;

            const focusDistanceForHeight = halfFocusZ / Math.tan(fov / 2);
            const focusDistanceForWidth = halfFocusX / Math.tan(horizontalFov / 2);
            const focusDistance =
              Math.max(focusDistanceForHeight, focusDistanceForWidth) * 1.1;

            // Kamera direkt √ºber dem zooming-Objekt positionieren (von oben schauen)
            // Damit ist das Objekt genau zentriert und nicht vom Rest des Modells beeinflusst
            const focusPosition = new THREE.Vector3(
              worldCenter.x,
              worldCenter.y + focusDistance,
              worldCenter.z
            );

            focusMesh.traverse((child) => {
              child.visible = false;
            });

            if (controls.target0) {
              controls.target0.copy(worldCenter);
            }
            if (controls.position0) {
              controls.position0.copy(focusPosition);
            }
            if (controls.zoom0 !== undefined) {
              controls.zoom0 = camera.zoom;
            }

            const focusDelayMs = 600;
            const focusDurationMs = 1600;
            setTimeout(() => {
              startZoomAnimation(worldCenter, focusPosition, focusDurationMs);
            }, focusDelayMs);
          }
         },
        (progress) => {
          if (isLoadingComplete) return;
          if (progress.total > 0) {
            const percent = (progress.loaded / progress.total) * 100;
            updateProgress(
              'download',
              Math.min(percent, 99),
              `${formatBytes(progress.loaded)} / ${formatBytes(progress.total)} loaded`
            );
          } else {
            updateProgress('download', 50, `${formatBytes(progress.loaded)} loaded`);
          }
        },
         (error) => {
          console.error("Error loading GLB file:", error);
          updateProgress('error', 0, 'Error loading file', '');
          progressBar.style.background = "linear-gradient(90deg, #f44336, #d32f2f)";
          progressDetails.textContent = error.message || "Unknown error";
         }
      );

      function animate() {
        requestAnimationFrame(animate);
        if (zoomState.active) {
          const elapsed = performance.now() - zoomState.startTime;
          let t = elapsed / zoomState.duration;
          if (t >= 1) {
            zoomState.active = false;
            controls.target.copy(zoomState.endTarget);
            camera.position.copy(zoomState.endPosition);
            // Stelle sicher, dass die Kamera genau auf das Target schaut
            camera.lookAt(controls.target);
            controls.update();
          } else {
            const eased = THREE.MathUtils.smoothstep(t, 0, 1);
            controls.target
              .copy(zoomState.startTarget)
              .lerp(zoomState.endTarget, eased);
            camera.position
              .copy(zoomState.startPosition)
              .lerp(zoomState.endPosition, eased);
            camera.lookAt(controls.target);
          }
          controls.update();
          updateResetButtonVisibility();
        } else if (controlsStateChanged) {
          updateResetButtonVisibility();
          controlsStateChanged = false;
        }
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderer.domElement.addEventListener("dblclick", (event) => {
        event.preventDefault();
        handleZoomEvent(event.clientX, event.clientY);
      });

      renderer.domElement.addEventListener(
        "touchend",
        (event) => {
          if (event.touches.length > 0) {
            return;
          }

          const currentTime = performance.now();
          if (currentTime - lastTapTime < tapThresholdMs) {
            const touch = event.changedTouches[0];
            handleZoomEvent(touch.clientX, touch.clientY);
            lastTapTime = 0;
          } else {
            lastTapTime = currentTime;
          }
        },
        { passive: false }
      );

      resetButton.addEventListener("click", () => {
        const savedTarget = controls.target0 ? controls.target0.clone() : new THREE.Vector3();
        const savedPosition = controls.position0
          ? controls.position0.clone()
          : new THREE.Vector3().copy(camera.position);
        startZoomAnimation(savedTarget, savedPosition);
      });

      function updateResetButtonVisibility() {
        const targetChanged = !approxEquals(controls.target, controls.target0);
        const positionChanged = !approxEquals(camera.position, controls.position0);
        const shouldBeVisible = targetChanged || positionChanged || zoomState.active;
        resetButton.style.display = shouldBeVisible ? "flex" : "none";
      }

      controls.addEventListener("change", () => {
        controlsStateChanged = true;
      });

      updateResetButtonVisibility();

      // Language Dropdown Funktionalit√§t
      const languageDropdown = document.getElementById("languageDropdown");
      const languageButton = document.getElementById("languageButton");

      languageButton.addEventListener("click", (e) => {
        e.stopPropagation();
        languageDropdown.classList.toggle("open");
        languageButton.setAttribute("aria-expanded", languageDropdown.classList.contains("open"));
      });

      // Schlie√üe Dropdown beim Klick au√üerhalb
      document.addEventListener("click", (e) => {
        if (!languageDropdown.contains(e.target)) {
          languageDropdown.classList.remove("open");
          languageButton.setAttribute("aria-expanded", "false");
        }
      });

      // Schlie√üe Dropdown mit Escape-Taste
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && languageDropdown.classList.contains("open")) {
          languageDropdown.classList.remove("open");
          languageButton.setAttribute("aria-expanded", "false");
        }
      });

      // Aktualisiere Flagge im Button basierend auf ausgew√§hlter Sprache
      const languageMenuItems = document.querySelectorAll("#languageMenu a");
      const flagIcon = document.querySelector("#languageButton .flag-icon");
      
      languageMenuItems.forEach((item) => {
        item.addEventListener("click", (e) => {
          const flagSpan = item.querySelector(".flag");
          if (flagSpan) {
            flagIcon.textContent = flagSpan.textContent;
          }
        });
      });
    </script>
  </body>
</html>