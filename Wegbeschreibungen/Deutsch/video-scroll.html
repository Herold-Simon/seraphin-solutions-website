<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Scroll-Video</title>
<meta name="description" content="Vertical Scroll-Video (mobile optimiert)">
<link rel="icon" href="favicon.ico">
<style>
/* Mobile-first, keep CSS minimal and self-contained */
:root { overscroll-behavior-y: contain; }
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#000; color:#fff; }

/* Dedicated scroller for natural gesture, body stays locked */
#scroller { position: fixed; inset: 0; overflow-y: auto; -webkit-overflow-scrolling: touch; }
/* Height is set via JS based on duration */
#scroll-space { height: 100vh; }

/* Sticky video inside scroller */
#stage { position: sticky; top: 0; height: 100vh; width: 100vw; overflow: hidden; }
#video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; background: #000; }

/* No additional UI */
/* Prominent scroll hint */
#scroll-hint { position: fixed; inset: 0; display: flex; align-items: flex-end; justify-content: center; pointer-events: none; transition: opacity .35s ease; }
#scroll-hint.hidden { opacity: 0; }
#scroll-hint .hint-box { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: calc(env(safe-area-inset-bottom) + 72px); background: rgba(0,0,0,.55); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.18); box-shadow: 0 8px 24px rgba(0,0,0,.35); border-radius: 20px; padding: 16px 20px; transform: translateY(0); animation: hint-float 2s ease-in-out infinite; }
#scroll-hint .hint-text { font-size: 18px; line-height: 1.2; font-weight: 700; letter-spacing: .2px; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
#scroll-hint .chevron { width: 36px; height: 36px; stroke: #fff; stroke-width: 3; fill: none; opacity: .95; animation: hint-bounce 1.1s ease-in-out infinite; }

@keyframes hint-bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(6px); } }
@keyframes hint-float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(3px); } }

@media (min-width: 480px) { #scroll-hint .hint-text { font-size: 20px; } #scroll-hint .chevron { width: 40px; height: 40px; } }
@media (min-width: 768px) { #scroll-hint .hint-text { font-size: 22px; } #scroll-hint .hint-box { padding: 18px 24px; } }

@media (prefers-reduced-motion: reduce) { #scroll-hint .chevron, #scroll-hint .hint-box { animation: none; } }

/* No scroll locking to avoid blocking scroll */

/* Loading overlay while prebuffering the video */
body.loading #scroller { pointer-events: none; }
#loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,.6); color: #fff; font-weight: 700; letter-spacing: .2px; font-size: 16px; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
#loading.hidden { display: none; }
</style>
</head>
<body>
  <div id="scroller">
    <!-- Sticky stage with the video -->
    <div id="stage" aria-label="Scroll gesteuertes Video">
      <video id="video" playsinline preload="auto" muted>
        <source src="video1.mp4" type="video/mp4">
        Ihr Browser unterstützt das Video-Format nicht.
      </video>
    </div>

    <!-- Scroll area to control playback by scroll position -->
    <div id="scroll-space"></div>
  </div>
  <div id="loading" role="status" aria-live="polite">Video wird geladen …</div>
  <div id="scroll-hint">
    <div class="hint-box" aria-hidden="true">
      <svg class="chevron" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M6 9l6 6 6-6" stroke-linecap="round" stroke-linejoin="round"></path>
      </svg>
      <div class="hint-text">Bitte Runterwischen</div>
    </div>
  </div>

  

<script>
(function() {
  const video = document.getElementById('video');
  const scroller = document.getElementById('scroller');
  const scrollSpace = document.getElementById('scroll-space');
  const scrollHint = document.getElementById('scroll-hint');
  const loading = document.getElementById('loading');

  const EPS_END = 0.08; // clamp a bit before end to avoid black frame on some devices
  const TARGET_FPS = 30; // throttle seeks to ~30 fps
  const TIME_QUANT = 1 / 30; // quantize target time to reduce decoder load

  let duration = 0;
  let userInteracted = false;
  let rafPending = false;
  let pendingTime = null;
  let lastSeekAt = 0;

  // Keep video paused; we will drive currentTime directly
  function ensurePaused() {
    if (!video.paused) {
      video.pause().catch(() => {});
    }
  }

  function scheduleSeek(time) {
    pendingTime = time;
    if (rafPending) return;
    rafPending = true;
    window.requestAnimationFrame(function() {
      rafPending = false;
      if (pendingTime == null) return;
      const t = pendingTime;
      pendingTime = null;
      if (Math.abs(video.currentTime - t) > 0.02) {
        try { video.currentTime = t; } catch(e) {}
      }
    });
  }

  function updateScrollSpaceHeight() {
    if (!duration || !isFinite(duration)) return;
    const totalPixels = Math.max(1, Math.round(duration * 300));
    const targetHeight = totalPixels + (scroller.clientHeight || 0);
    scrollSpace.style.height = targetHeight + 'px';
  }

  function setTimeFromScroll(scrollY) {
    if (!duration || !isFinite(duration)) return;
    const maxScroll = Math.max(1, (scroller.scrollHeight - scroller.clientHeight));
    const clamped = Math.max(0, Math.min(scrollY, maxScroll));
    const progress = maxScroll > 0 ? (clamped / maxScroll) : 0;
    let targetTime = progress * Math.max(0, duration - EPS_END);
    // Quantize to reduce number of distinct frames requested
    targetTime = Math.max(0, Math.min(duration, Math.round(targetTime / TIME_QUANT) * TIME_QUANT));
    if (Math.abs(video.currentTime - targetTime) > 0.05) {
      try { video.currentTime = targetTime; } catch(e) {}
    }
  }

  // Handle metadata load to know duration
  function onLoadedMeta() {
    duration = Number(video.duration) || 0;
    // Start at beginning
    scroller.scrollTo(0, 0);
    setTimeFromScroll(0);
    ensurePaused();
    if (scrollHint) scrollHint.classList.remove('hidden');
  }

  // Some browsers require a user gesture for precise seeking; unlock on first gesture
  function onFirstUserGesture() {
    if (userInteracted) return;
    userInteracted = true;
    video.play().then(() => video.pause()).catch(() => {});
    ensurePaused();
    if (scrollHint) scrollHint.classList.add('hidden');
  }

  // Use scroller's native scroll for control, body stays fixed
  scroller.addEventListener('scroll', function() {
    if (scrollHint && scroller.scrollTop > 2) scrollHint.classList.add('hidden');
    const y = scroller.scrollTop;
    const now = performance.now();
    // Throttle to TARGET_FPS
    if (now - lastSeekAt < (1000 / TARGET_FPS)) return;
    lastSeekAt = now;
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(function() {
      rafPending = false;
      setTimeFromScroll(y);
    });
  }, { passive: true });

  window.addEventListener('resize', updateScrollSpaceHeight, { passive: true });
  window.addEventListener('touchstart', onFirstUserGesture, { passive: true });
  window.addEventListener('pointerdown', onFirstUserGesture, { passive: true });

  // Fully preload the video as a Blob for smooth scrubbing
  const SOURCE_URL = 'video1.mp4';
  async function preloadFully() {
    try {
      document.body.classList.add('loading');
      if (loading) loading.classList.remove('hidden');
      const response = await fetch(SOURCE_URL, { cache: 'force-cache' });
      const blob = await response.blob();
      const objectUrl = URL.createObjectURL(blob);
      video.src = objectUrl;
      await new Promise(resolve => {
        if (video.readyState >= 1) return resolve();
        video.addEventListener('loadedmetadata', resolve, { once: true });
      });
      updateScrollSpaceHeight();
    } catch (e) {
      // Fallback: keep using source element
    } finally {
      document.body.classList.remove('loading');
      if (loading) loading.classList.add('hidden');
    }
  }

  preloadFully();

  document.addEventListener('visibilitychange', ensurePaused);

  video.addEventListener('loadedmetadata', onLoadedMeta);
  video.addEventListener('play', ensurePaused); // keep it paused

  // Fallback: if metadata never loads, attempt after small delay
  setTimeout(() => { if (!duration) onLoadedMeta(); }, 1500);

  // Init
})();
</script>
</body>
</html>

