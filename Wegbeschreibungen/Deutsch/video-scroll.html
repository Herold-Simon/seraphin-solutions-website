<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Scroll-Video</title>
<meta name="description" content="Vertical Scroll-Video (mobile optimiert)">
<link rel="icon" href="favicon.ico">
<style>
/* Mobile-first, keep CSS minimal and self-contained */
:root { overscroll-behavior-y: contain; }
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#000; color:#fff; }

/* Dedicated scroller for natural gesture, body stays locked */
#scroller { position: fixed; inset: 0; overflow-y: auto; -webkit-overflow-scrolling: touch; }
/* Height is set via JS based on duration */
#scroll-space { height: 100vh; }

/* Sticky video inside scroller */
#stage { position: sticky; top: 0; height: 100vh; width: 100vw; overflow: hidden; }
#video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; background: #000; opacity: 0; visibility: hidden; }
#video.fallback { opacity: 1; visibility: visible; }
#frameCanvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; background: #000; }
#frameCanvas.fallback { display: none; }

/* Back button */
#back-button { position: fixed; top: calc(env(safe-area-inset-top) + 16px); left: calc(env(safe-area-inset-left) + 16px); z-index: 1001; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,.6); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,.2); border-radius: 50%; cursor: pointer; transition: background .2s, transform .1s; }
#back-button:hover { background: rgba(0,0,0,.75); }
#back-button:active { transform: scale(.95); }
#back-button svg { width: 24px; height: 24px; stroke: #fff; stroke-width: 2.5; fill: none; stroke-linecap: round; stroke-linejoin: round; }

/* No scroll locking to avoid blocking scroll */

/* Loading overlay while prebuffering the video */
body.loading #scroller { pointer-events: none; }
#loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,.6); color: #fff; font-weight: 700; letter-spacing: .2px; font-size: 16px; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
#loading.hidden { display: none; }

/* Tutorial overlay */
#tutorial-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.75); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity .4s ease, visibility .4s; pointer-events: none; }
#tutorial-overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
#tutorial-content { text-align: center; color: #fff; max-width: 320px; padding: 24px; pointer-events: none; }
#tutorial-title { font-size: 22px; font-weight: 700; margin-bottom: 32px; margin-top: -120px; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
#tutorial-arrow-container { position: relative; width: 100%; height: 200px; margin-top: 20px; }
#tutorial-arrow { position: absolute; left: 50%; transform: translateX(-50%); width: 48px; height: 48px; fill: #fff; animation: arrow-fly 2s ease-in-out infinite; }

@keyframes arrow-fly {
  0% { bottom: 0; opacity: 0; }
  20% { opacity: 1; }
  80% { opacity: 1; }
  100% { bottom: 100%; opacity: 0; }
}

@media (min-width: 480px) {
  #tutorial-title { font-size: 24px; }
  #tutorial-text { font-size: 17px; }
  #tutorial-content { max-width: 400px; }
}
</style>
</head>
<body>
  <div id="scroller">
    <!-- Sticky stage with the video -->
    <div id="stage" aria-label="Scroll gesteuertes Video">
      <video id="video" playsinline preload="auto" muted>
        <source src="video1.mp4" type="video/mp4">
        Ihr Browser unterstützt das Video-Format nicht.
      </video>
      <canvas id="frameCanvas"></canvas>
    </div>

    <!-- Scroll area to control playback by scroll position -->
    <div id="scroll-space"></div>
  </div>
  <div id="loading" role="status" aria-live="polite">Video wird geladen …</div>
  <a id="back-button" href="../../index.html" aria-label="Zurück zur Startseite">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M15 18l-6-6 6-6"></path>
    </svg>
  </a>
  <div id="tutorial-overlay" role="dialog" aria-labelledby="tutorial-title" aria-modal="true">
    <div id="tutorial-content">
      <div id="tutorial-title">Für Navigation Swipen</div>
      <div id="tutorial-arrow-container">
        <svg id="tutorial-arrow" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M9 11.24V7.5a2.5 2.5 0 0 1 5 0v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z" fill="currentColor"></path>
        </svg>
      </div>
    </div>
  </div>

  

<script>
(function() {
  const video = document.getElementById('video');
  const stage = document.getElementById('stage');
  const scroller = document.getElementById('scroller');
  const scrollSpace = document.getElementById('scroll-space');
  const loading = document.getElementById('loading');
  const tutorialOverlay = document.getElementById('tutorial-overlay');
  const frameCanvas = document.getElementById('frameCanvas');
  const frameCtx = frameCanvas.getContext('2d', { alpha: false });

  const EPS_END = 0.08; // clamp a bit before end to avoid black frame on some devices
  const TIME_QUANT_BASE_FINE = 1 / 30; // used bei langsamer Bewegung
  const TIME_QUANT_BASE_COARSE = 1 / 15; // used bei schneller Bewegung

  let duration = 0;
  let userInteracted = false;
  let rafPending = false;
  let pendingTime = null;
  let targetProgress = 0; // 0..1 from scroll position
  let currentProgress = 0; // smoothed progress for display
  let lastRafTime = performance.now();
  let seeking = false;
  let queuedTargetTime = null;
  let lastSeekTime = 0;
  const MIN_SEEK_INTERVAL = 50; // Minimum milliseconds between seeks

  // Keep video paused; we will drive currentTime directly
  function ensurePaused() {
    if (!video.paused) {
      video.pause().catch(() => {});
    }
  }

  function scheduleSeek(time) {
    pendingTime = time;
    if (rafPending) return;
    rafPending = true;
    window.requestAnimationFrame(function() {
      rafPending = false;
      if (pendingTime == null) return;
      const t = pendingTime;
      pendingTime = null;
      if (Math.abs(video.currentTime - t) > 0.02) {
        try { video.currentTime = t; } catch(e) {}
      }
    });
  }

  function updateScrollSpaceHeight() {
    if (!duration || !isFinite(duration)) return;
    const totalPixels = Math.max(1, Math.round(duration * 300));
    const targetHeight = totalPixels + (scroller.clientHeight || 0);
    scrollSpace.style.height = targetHeight + 'px';
  }
  let lastDpr = 1;
  function resizeCanvas() {
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    if (!w || !h) return;
    // Use devicePixelRatio for sharper rendering on mobile, but cap it for performance
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    // Only resize if dimensions or DPR changed
    if (frameCanvas.width === w * dpr && frameCanvas.height === h * dpr && lastDpr === dpr) {
      return;
    }
    lastDpr = dpr;
    frameCanvas.width = w * dpr;
    frameCanvas.height = h * dpr;
    frameCanvas.style.width = w + 'px';
    frameCanvas.style.height = h + 'px';
    // Reset transform and apply scale
    frameCtx.setTransform(1, 0, 0, 1, 0, 0);
    frameCtx.scale(dpr, dpr);
    // Redraw after resize
    if (video.videoWidth && video.videoHeight) {
      drawCurrentFrameToCanvas();
    }
  }
  function drawCurrentFrameToCanvas() {
    if (!video.videoWidth || !video.videoHeight) return;
    const cw = frameCanvas.width;
    const ch = frameCanvas.height;
    if (!cw || !ch) {
      // Ensure canvas is sized
      resizeCanvas();
      return;
    }
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    // Account for devicePixelRatio scaling
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const displayW = cw / dpr;
    const displayH = ch / dpr;
    const scale = Math.min(displayW / vw, displayH / vh);
    const drawW = Math.round(vw * scale);
    const drawH = Math.round(vh * scale);
    const dx = Math.round((displayW - drawW) / 2);
    const dy = Math.round((displayH - drawH) / 2);
    frameCtx.fillStyle = '#000';
    frameCtx.fillRect(0, 0, displayW, displayH);
    try { frameCtx.drawImage(video, dx, dy, drawW, drawH); } catch(e) {
      console.warn('Error drawing frame to canvas:', e);
    }
  }

  function setTimeFromScroll(scrollY) {
    if (!duration || !isFinite(duration)) return;
    const maxScroll = Math.max(1, (scroller.scrollHeight - scroller.clientHeight));
    const clamped = Math.max(0, Math.min(scrollY, maxScroll));
    const progress = maxScroll > 0 ? (clamped / maxScroll) : 0;
    targetProgress = progress;
    // Nur Ziel setzen; Quantisierung passiert im RAF adaptiv
    queuedTargetTime = progress * Math.max(0, duration - EPS_END);
  }

  // Handle metadata load to know duration
  function onLoadedMeta() {
    duration = Number(video.duration) || 0;
    // Start at beginning
    scroller.scrollTo(0, 0);
    setTimeFromScroll(0);
    ensurePaused();
    resizeCanvas();
    // Force initial draw on mobile
    requestAnimationFrame(() => {
      drawCurrentFrameToCanvas();
    });
  }

  // Some browsers require a user gesture for precise seeking; unlock on first gesture
  function onFirstUserGesture() {
    if (userInteracted) return;
    userInteracted = true;
    video.play().then(() => video.pause()).catch(() => {});
    ensurePaused();
    // Hide tutorial on first interaction
    hideTutorial();
  }

  // Tutorial management
  const TUTORIAL_KEY = 'video-scroll-tutorial-seen';
  function showTutorial() {
    const hasSeenTutorial = localStorage.getItem(TUTORIAL_KEY);
    if (!hasSeenTutorial && tutorialOverlay) {
      tutorialOverlay.classList.remove('hidden');
    }
  }

  function hideTutorial() {
    if (tutorialOverlay && !tutorialOverlay.classList.contains('hidden')) {
      tutorialOverlay.classList.add('hidden');
      localStorage.setItem(TUTORIAL_KEY, 'true');
    }
  }

  // Use scroller's native scroll for control, body stays fixed
  scroller.addEventListener('scroll', function() {
    // Hide tutorial on scroll
    if (scroller.scrollTop > 5) hideTutorial();
    const y = scroller.scrollTop;
    // Only update the target; actual seek is handled in RAF for smoothness
    setTimeFromScroll(y);
  }, { passive: true });

  // Smoothly interpolate toward target progress and drive the video time in RAF
  function rafTick(now) {
    const dt = Math.max(0, Math.min(100, now - lastRafTime));
    lastRafTime = now;
    if (duration && isFinite(duration)) {
      // Minimale Glättung nur für Seeks, nicht für Canvas-Anzeige
      const diff = Math.abs(targetProgress - currentProgress);
      const tauMs = diff > 0.2 ? 100 : 60; // Schnellere Reaktion
      const alpha = 1 - Math.exp(-dt / tauMs);
      currentProgress += (targetProgress - currentProgress) * alpha;

      // Adaptive Quantisierung: grober bei schnellen Bewegungen, feiner bei langsamen
      const quant = diff > 0.2 ? TIME_QUANT_BASE_COARSE : TIME_QUANT_BASE_FINE;
      let smoothedTime = Math.max(0, Math.min(duration - EPS_END, currentProgress * (duration - EPS_END)));
      smoothedTime = Math.round(smoothedTime / quant) * quant;

      const desiredTimeRaw = queuedTargetTime != null ? queuedTargetTime : smoothedTime;
      const desiredTime = Math.round(desiredTimeRaw / quant) * quant;
      const now = performance.now();
      const timeSinceLastSeek = now - lastSeekTime;
      
      // Always draw canvas when not seeking - this ensures smooth display
      // The video is hidden anyway, so canvas must always show current frame
      if (!seeking) {
        drawCurrentFrameToCanvas();
      }
      
      if (!seeking && timeSinceLastSeek >= MIN_SEEK_INTERVAL && Math.abs(video.currentTime - desiredTime) > 0.03) {
        // Draw current frame to canvas before seeking to prevent flicker
        drawCurrentFrameToCanvas();
        
        seeking = true;
        lastSeekTime = now;
        queuedTargetTime = null;
        
        let seekCompleted = false;
        const onSeeked = () => {
          video.removeEventListener('seeked', onSeeked);
          if (seekCompleted) return;
          seekCompleted = true;
          // Update canvas with new frame immediately when seek completes
          requestAnimationFrame(() => {
            drawCurrentFrameToCanvas();
            requestAnimationFrame(() => {
              seeking = false;
            });
          });
        };
        video.addEventListener('seeked', onSeeked);
        
        try { 
          video.currentTime = desiredTime;
          // Fallback timeout
          setTimeout(() => {
            if (!seekCompleted) {
              seekCompleted = true;
              drawCurrentFrameToCanvas();
              seeking = false;
            }
          }, 150);
        } catch(e) { 
          seeking = false;
        }
      }
    }
    requestAnimationFrame(rafTick);
  }
  requestAnimationFrame(rafTick);

  window.addEventListener('resize', function(){ updateScrollSpaceHeight(); resizeCanvas(); }, { passive: true });
  window.addEventListener('touchstart', onFirstUserGesture, { passive: true });
  window.addEventListener('pointerdown', onFirstUserGesture, { passive: true });

  // Auto-scroll on click/tap anywhere on screen
  let tapStartY = null;
  let tapStartTime = 0;
  let lastTouchY = null;
  const SCROLL_AMOUNT_RATIO = 0.6; // Scroll 60% of viewport height on click/tap
  const doAutoScroll = (e) => {
    // Only trigger if it was a quick tap, not a scroll gesture
    const now = performance.now();
    const timeSinceTap = now - tapStartTime;
    if (tapStartY !== null && timeSinceTap < 300 && Math.abs((e.changedTouches?.[0]?.clientY || e.clientY) - tapStartY) < 10) {
      onFirstUserGesture();
      const scrollAmount = scroller.clientHeight * SCROLL_AMOUNT_RATIO;
      scroller.scrollBy({ top: scrollAmount, behavior: 'smooth' });
    }
    tapStartY = null;
    lastTouchY = null;
  };

  document.addEventListener('touchstart', function(e) {
    if (e.touches && e.touches[0]) {
      tapStartY = e.touches[0].clientY;
      lastTouchY = e.touches[0].clientY;
      tapStartTime = performance.now();
    }
  }, { passive: true });

  document.addEventListener('touchmove', function(e) {
    if (e.touches && e.touches[0] && lastTouchY !== null) {
      const currentY = e.touches[0].clientY;
      const deltaY = lastTouchY - currentY; // Positive = swiping up
      // Hide tutorial if swiping up (more than 20px)
      if (deltaY > 20) {
        hideTutorial();
      }
      lastTouchY = currentY;
    }
  }, { passive: true });

  document.addEventListener('touchend', doAutoScroll, { passive: true });

  document.addEventListener('click', function(e) {
    onFirstUserGesture();
    const scrollAmount = scroller.clientHeight * SCROLL_AMOUNT_RATIO;
    scroller.scrollBy({ top: scrollAmount, behavior: 'smooth' });
  }, { passive: true });

  // Fully preload the video as a Blob for smooth scrubbing
  // Try multiple possible paths for the video
  const possiblePaths = [
    'video1.mp4',  // Same directory
    './video1.mp4', // Explicit relative
    '../video1.mp4', // Parent directory (in case video is in parent)
    '/video1.mp4',  // Root (if hosted at root)
  ];
  
  async function preloadFully() {
    try {
      document.body.classList.add('loading');
      if (loading) loading.classList.remove('hidden');
      
      let videoLoaded = false;
      let lastError = null;
      
      // Try each possible path
      for (const SOURCE_URL of possiblePaths) {
        try {
          const response = await fetch(SOURCE_URL, { cache: 'force-cache' });
          if (!response.ok) continue;
          const blob = await response.blob();
          const objectUrl = URL.createObjectURL(blob);
          video.src = objectUrl;
          await new Promise(resolve => {
            if (video.readyState >= 1) return resolve();
            video.addEventListener('loadedmetadata', resolve, { once: true });
          });
          updateScrollSpaceHeight();
          // Ensure canvas is ready on mobile
          resizeCanvas();
          requestAnimationFrame(() => {
            drawCurrentFrameToCanvas();
          });
          videoLoaded = true;
          break;
        } catch (e) {
          lastError = e;
          continue;
        }
      }
      
      // If all paths failed, fallback to source element
      if (!videoLoaded) {
        // Let the browser handle the <source> tag - ensure it's set correctly
        const sourceElement = video.querySelector('source');
        if (sourceElement && sourceElement.src) {
          video.src = sourceElement.src;
        } else {
          // Try setting src directly as last resort
          video.src = 'video1.mp4';
        }
        // Wait a bit for browser to load from source element
        await new Promise(resolve => setTimeout(resolve, 100));
        if (video.readyState >= 1 || video.readyState === 0) {
          updateScrollSpaceHeight();
        }
        // On mobile, if canvas might not work, show video directly as fallback
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
          video.classList.add('fallback');
          frameCanvas.classList.add('fallback');
          console.warn('Using video element directly on mobile (canvas fallback)');
        } else {
          console.warn('Using video source element instead of blob preload');
        }
      }
    } catch (e) {
      console.error('Error preloading video:', e);
      // Fallback: keep using source element
    } finally {
      document.body.classList.remove('loading');
      if (loading) loading.classList.add('hidden');
    }
  }

  preloadFully();

  document.addEventListener('visibilitychange', ensurePaused);

  video.addEventListener('loadedmetadata', onLoadedMeta);
  video.addEventListener('play', ensurePaused); // keep it paused

  // Fallback: if metadata never loads, attempt after small delay
  setTimeout(() => { if (!duration) onLoadedMeta(); }, 1500);

  // Show tutorial after page load
  window.addEventListener('load', function() {
    setTimeout(showTutorial, 500);
  }, { once: true });

  // Init
})();
</script>
</body>
</html>

