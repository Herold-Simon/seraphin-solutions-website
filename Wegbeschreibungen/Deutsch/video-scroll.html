<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Scroll-Video</title>
<meta name="description" content="Vertical Scroll-Video (mobile optimiert)">
<link rel="icon" href="favicon.ico">
<style>
/* Mobile-first, keep CSS minimal and self-contained */
:root { overscroll-behavior-y: contain; }
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#000; color:#fff; }

/* Scroll space no longer used for native scrolling */
#scroll-space { height: 0; }

/* Fixed viewport video to ensure consistent behavior */
#stage { position: fixed; top: 0; left: 0; height: 100vh; width: 100vw; overflow: hidden; }
#video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; background: #000; }

/* No additional UI */
/* Prominent scroll hint */
#scroll-hint { position: fixed; inset: 0; display: flex; align-items: flex-end; justify-content: center; pointer-events: none; transition: opacity .35s ease; }
#scroll-hint.hidden { opacity: 0; }
#scroll-hint .hint-box { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: calc(env(safe-area-inset-bottom) + 72px); background: rgba(0,0,0,.55); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.18); box-shadow: 0 8px 24px rgba(0,0,0,.35); border-radius: 20px; padding: 16px 20px; transform: translateY(0); animation: hint-float 2s ease-in-out infinite; }
#scroll-hint .hint-text { font-size: 18px; line-height: 1.2; font-weight: 700; letter-spacing: .2px; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
#scroll-hint .chevron { width: 36px; height: 36px; stroke: #fff; stroke-width: 3; fill: none; opacity: .95; animation: hint-bounce 1.1s ease-in-out infinite; }

@keyframes hint-bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(6px); } }
@keyframes hint-float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(3px); } }

@media (min-width: 480px) { #scroll-hint .hint-text { font-size: 20px; } #scroll-hint .chevron { width: 40px; height: 40px; } }
@media (min-width: 768px) { #scroll-hint .hint-text { font-size: 22px; } #scroll-hint .hint-box { padding: 18px 24px; } }

@media (prefers-reduced-motion: reduce) { #scroll-hint .chevron, #scroll-hint .hint-box { animation: none; } }

/* No scroll locking to avoid blocking scroll */
</style>
</head>
<body>
  <!-- Sticky stage with the video -->
  <div id="stage" aria-label="Scroll gesteuertes Video">
    <video id="video" playsinline preload="metadata" muted>
      <source src="video1.mp4" type="video/mp4">
      Ihr Browser unterst√ºtzt das Video-Format nicht.
    </video>
  </div>

  <!-- Legacy element (not used for native scroll anymore) -->
  <div id="scroll-space"></div>
  <div id="scroll-hint">
    <div class="hint-box" aria-hidden="true">
      <svg class="chevron" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M6 9l6 6 6-6" stroke-linecap="round" stroke-linejoin="round"></path>
      </svg>
      <div class="hint-text">Bitte Runterwischen</div>
    </div>
  </div>

  

<script>
(function() {
  const video = document.getElementById('video');
  const scrollSpace = document.getElementById('scroll-space');
  const scrollHint = document.getElementById('scroll-hint');

  // Prefer preloading for smoother scrubbing
  try { video.preload = 'auto'; } catch(e) {}

  // Pixels per second of video to scroll through (tune for feel)
  // Virtual scrubbing config
  const SCROLL_PIXELS_FOR_FULL = 1500; // drag amount to cover entire video
  const EPS_END = 0.08; // clamp a bit before end to avoid black frame on some devices

  let duration = 0;
  let userInteracted = false;
  let progress = 0; // 0..1
  let rafPending = false;
  let pendingTime = null;
  let isPointerDown = false;
  let lastY = 0;

  // Keep video paused; we will drive currentTime directly
  function ensurePaused() {
    if (!video.paused) {
      video.pause().catch(() => {});
    }
  }

  function scheduleSeek(time) {
    pendingTime = time;
    if (rafPending) return;
    rafPending = true;
    window.requestAnimationFrame(function() {
      rafPending = false;
      if (pendingTime == null) return;
      const t = pendingTime;
      pendingTime = null;
      if (Math.abs(video.currentTime - t) > 0.02) {
        try { video.currentTime = t; } catch(e) {}
      }
    });
  }

  function applyProgress() {
    if (!duration || !isFinite(duration)) return;
    const clampedProgress = Math.max(0, Math.min(1, progress));
    const target = clampedProgress * Math.max(0, duration - EPS_END);
    scheduleSeek(target);
  }

  function nudgeProgress(deltaPixels) {
    const delta = deltaPixels / SCROLL_PIXELS_FOR_FULL;
    progress = Math.max(0, Math.min(1, progress + delta));
    if (scrollHint && Math.abs(deltaPixels) > 1) scrollHint.classList.add('hidden');
    applyProgress();
  }

  // Handle metadata load to know duration
  function onLoadedMeta() {
    duration = Number(video.duration) || 0;
    // Start at beginning
    progress = 0;
    applyProgress();
    ensurePaused();
    if (scrollHint) scrollHint.classList.remove('hidden');
  }

  // Some browsers require a user gesture for precise seeking; unlock on first gesture
  function onFirstUserGesture() {
    if (userInteracted) return;
    userInteracted = true;
    video.play().then(() => video.pause()).catch(() => {});
    ensurePaused();
    if (scrollHint) scrollHint.classList.add('hidden');
  }

  // Event wiring
  // Input: wheel
  window.addEventListener('wheel', function(e) {
    e.preventDefault();
    onFirstUserGesture();
    const scale = (e.ctrlKey || e.metaKey) ? 0.25 : 1; // finer control with pinch/ctrl
    nudgeProgress(e.deltaY * 0.0015 * scale * (window.innerHeight / 700));
  }, { passive: false });

  // Input: touch / pointer drag
  window.addEventListener('touchstart', function(e) {
    onFirstUserGesture();
    if (e.touches && e.touches[0]) {
      lastY = e.touches[0].clientY;
      isPointerDown = true;
    }
  }, { passive: true });

  window.addEventListener('touchmove', function(e) {
    if (!isPointerDown) return;
    if (e.touches && e.touches[0]) {
      const y = e.touches[0].clientY;
      const dy = lastY - y;
      lastY = y;
      nudgeProgress(dy);
      e.preventDefault();
    }
  }, { passive: false });

  window.addEventListener('touchend', function() { isPointerDown = false; }, { passive: true });

  window.addEventListener('pointerdown', function(e) {
    if (e.pointerType === 'mouse') return; // mouse handled by wheel typically
    onFirstUserGesture();
    isPointerDown = true;
    lastY = e.clientY;
  }, { passive: true });

  window.addEventListener('pointermove', function(e) {
    if (!isPointerDown) return;
    const y = e.clientY;
    const dy = lastY - y;
    lastY = y;
    nudgeProgress(dy);
  }, { passive: true });

  window.addEventListener('pointerup', function() { isPointerDown = false; }, { passive: true });
  document.addEventListener('visibilitychange', ensurePaused);

  video.addEventListener('loadedmetadata', onLoadedMeta);
  video.addEventListener('play', ensurePaused); // keep it paused

  // No scroll locking

  // Fallback: if metadata never loads, attempt after small delay
  setTimeout(() => { if (!duration) onLoadedMeta(); }, 1500);

  // Init
})();
</script>
</body>
</html>

